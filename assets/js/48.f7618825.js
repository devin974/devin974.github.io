(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{664:function(v,_,t){"use strict";t.r(_);var l=t(9),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("strong",[v._v("什么是设计模式？")])]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("设计模式")]),v._v("是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。")])]),v._v(" "),t("li",[t("p",[v._v("设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， "),t("strong",[v._v("而是解决特定问题的一般性概念")]),v._v("。 你可以根据模式来实现符合自己程序实际所需的解决方案。")])]),v._v(" "),t("li",[t("p",[v._v("人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。")])]),v._v(" "),t("li",[t("p",[v._v("算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。")])])]),v._v(" "),t("hr"),v._v(" "),t("p",[t("strong",[v._v("为什么要学习设计模式？")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("设计模式来源于众多前人的经验和智慧，它们是从许多的实践和优秀的系统项目中总结提炼出来的设计方案")])]),v._v(" "),t("li",[t("p",[v._v("可以提高程序员的思维能力、编程能力和设计能力。")])]),v._v(" "),t("li",[t("p",[v._v("使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。")])]),v._v(" "),t("li",[t("p",[v._v("使设计的代码可复用性高、可读性强、可靠性高、灵活性好、可维护性强。")])])]),v._v(" "),t("h2",{attrs:{id:"模式分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式分类"}},[v._v("#")]),v._v(" 模式分类")]),v._v(" "),t("p",[v._v("设计模式可以有两种方法来进行分类（以下我们采用"),t("strong",[v._v("第一种")]),v._v("划分方式进行介绍）：")]),v._v(" "),t("ol",[t("li",[v._v("第一种可以根据其 "),t("strong",[v._v("目的")]),v._v("，通过解决什么样的问题来进行划分，可分为："),t("strong",[v._v("创建型、结构型、行为型")]),v._v(" 三种。")]),v._v(" "),t("li",[v._v("第二种可以根据其作用范围来进行划分，根据其作用与类上还是对象上，可分为："),t("strong",[v._v("类模式、对象模式")]),v._v(" 两种。")])]),v._v(" "),t("ul",[t("li",[v._v("创建型")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。")])])]),v._v(" "),t("ol",[t("li",[v._v("工厂方法模式（Factory Method）")]),v._v(" "),t("li",[v._v("抽象工厂模式（Abstract Factory）")]),v._v(" "),t("li",[v._v("生成器模式（Builder）")]),v._v(" "),t("li",[v._v("原型模式（Prototype）")]),v._v(" "),t("li",[v._v("单例模式（Singleton）")])]),v._v(" "),t("ul",[t("li",[v._v("结构型")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。")])])]),v._v(" "),t("ol",[t("li",[v._v("适配器模式（Adapter）")]),v._v(" "),t("li",[v._v("桥接模式（Bridge）")]),v._v(" "),t("li",[v._v("组合模式（Composite Pattern）")]),v._v(" "),t("li",[v._v("装饰模式（Decorator）")]),v._v(" "),t("li",[v._v("外观模式（Facade）")]),v._v(" "),t("li",[v._v("享元模式（Flyweight）")]),v._v(" "),t("li",[v._v("代理模式（Proxy）")])]),v._v(" "),t("ul",[t("li",[v._v("行为型")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("行为模式负责对象间的高效沟通和职责委派。")])])]),v._v(" "),t("ol",[t("li",[v._v("责任链模式（Chain of Responsibility）")]),v._v(" "),t("li",[v._v("命令模式（Command）")]),v._v(" "),t("li",[v._v("迭代器模式（Iterator）")]),v._v(" "),t("li",[v._v("中介者模式（Mediator）")]),v._v(" "),t("li",[v._v("备忘录模式（Memento）")]),v._v(" "),t("li",[v._v("观察者模式（Observer）")]),v._v(" "),t("li",[v._v("状态模式（State）")]),v._v(" "),t("li",[v._v("策略模式（Strategy）")]),v._v(" "),t("li",[v._v("模板方法模式（Template Method）")]),v._v(" "),t("li",[v._v("访问者模式（Visitor）")])])])}),[],!1,null,null,null);_.default=i.exports}}]);