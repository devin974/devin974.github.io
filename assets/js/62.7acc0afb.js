(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{687:function(t,a,v){"use strict";v.r(a);var _=v(9),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"第一次面试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一次面试"}},[t._v("#")]),t._v(" 第一次面试")]),t._v(" "),v("h3",{attrs:{id:"自我介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[t._v("#")]),t._v(" 自我介绍")]),t._v(" "),v("h3",{attrs:{id:"var-let-const的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#var-let-const的区别"}},[t._v("#")]),t._v(" var let const的区别")]),t._v(" "),v("ul",[v("li",[t._v("var")])]),t._v(" "),v("ol",[v("li",[t._v("有变量声明提升，可先使用后声明；")]),t._v(" "),v("li",[t._v("可重复声明；")]),t._v(" "),v("li",[t._v("函数作用域，无块级作用域。")])]),t._v(" "),v("ul",[v("li",[t._v("let")])]),t._v(" "),v("ol",[v("li",[t._v("有块级作用域；")]),t._v(" "),v("li",[t._v("不可重复声明；")]),t._v(" "),v("li",[t._v("不能先使用后声明，否则会出现暂时性死区；")])]),t._v(" "),v("ul",[v("li",[t._v("const")])]),t._v(" "),v("ol",[v("li",[t._v("有块级作用域；")]),t._v(" "),v("li",[t._v("不可重复声明；")]),t._v(" "),v("li",[t._v("不能先使用后声明，否则会出现暂时性死区；")]),t._v(" "),v("li",[t._v("声明的变量为常量不可更改，但是对象可以内的属性可以更改，因为存储的是对象的指针。")])]),t._v(" "),v("h3",{attrs:{id:"var的优缺点-全局变量的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#var的优缺点-全局变量的优缺点"}},[t._v("#")]),t._v(" var的优缺点（全局变量的优缺点）")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("优点\nvar声明的全局变量，可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗。")])]),t._v(" "),v("li",[v("p",[t._v("缺点")])])]),t._v(" "),v("ol",[v("li",[t._v("过多的全局变量会占用较多的内存单元；")]),t._v(" "),v("li",[t._v("全局变量破坏了函数的封装性能；")]),t._v(" "),v("li",[t._v("全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。")])]),t._v(" "),v("h3",{attrs:{id:"变量声明提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量声明提升"}},[t._v("#")]),t._v(" 变量声明提升")]),t._v(" "),v("p",[t._v("1.用var声明的全局变量，会声明提升，在读取脚本的时候提升到顶部；\n2.函数也会提升，可以先使用后声明。")]),t._v(" "),v("h3",{attrs:{id:"es6新增属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#es6新增属性"}},[t._v("#")]),t._v(" es6新增属性")]),t._v(" "),v("ol",[v("li",[t._v("Symbol；")]),t._v(" "),v("li",[t._v("let,const；")]),t._v(" "),v("li",[t._v("模版字符串；")]),t._v(" "),v("li",[t._v("对象字面量简写法；")]),t._v(" "),v("li",[t._v("class类；")]),t._v(" "),v("li",[t._v("箭头函数；")]),t._v(" "),v("li",[t._v("函数默认参数；")]),t._v(" "),v("li",[t._v("解构赋值；")]),t._v(" "),v("li",[t._v("拓展运算符；")]),t._v(" "),v("li",[t._v("import；")]),t._v(" "),v("li",[t._v("reduce；")]),t._v(" "),v("li",[t._v("forEach,map,filter；")]),t._v(" "),v("li",[t._v("Set,Map,WeakMap,TypedArray。")])]),t._v(" "),v("h3",{attrs:{id:"h5固定底部菜单的实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#h5固定底部菜单的实现方式"}},[t._v("#")]),t._v(" h5固定底部菜单的实现方式")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/html/html-sticky-footer.html"}},[t._v("h5的底部菜单的5种实现方式")])],1),t._v(" "),v("h3",{attrs:{id:"typeof"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typeof"}},[t._v("#")]),t._v(" typeof")]),t._v(" "),v("p",[t._v("typeof 的实现原理是因为js底层对变量都是用二进制存储的存储，低位的前三位都为0则为对象，而null全为0所以判断也为object,010为浮点数，100字符串，110布尔，1为整数。")]),t._v(" "),v("h3",{attrs:{id:"instanceof底层实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#instanceof底层实现原理"}},[t._v("#")]),t._v(" instanceOf底层实现原理")]),t._v(" "),v("p",[t._v("instanceOf的底层原理是，通过判断左侧的实例的__proto__是否和右侧的构造函数的prototype相等，如果相等的话就返回true,如果不相等的话就返回false。")]),t._v(" "),v("h3",{attrs:{id:"this指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[t._v("#")]),t._v(" this指向")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/js/js-this.html"}},[t._v("this指向详解")])],1),t._v(" "),v("h3",{attrs:{id:"实现new"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现new"}},[t._v("#")]),t._v(" 实现new")]),t._v(" "),v("h3",{attrs:{id:"call-apply-bind"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind"}},[t._v("#")]),t._v(" call apply bind")]),t._v(" "),v("h3",{attrs:{id:"map-set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map-set"}},[t._v("#")]),t._v(" Map Set")]),t._v(" "),v("p",[t._v("Set 和 Map 主要的应用场景在于 数据重组 和 数据储存")]),t._v(" "),v("p",[t._v("Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("集合（Set）\nES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。")])]),t._v(" "),v("li",[v("p",[t._v("字典（Map）\n集合 与 字典 的区别：")])])]),t._v(" "),v("p",[t._v("共同点：集合、字典 可以储存不重复的值\n不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存")]),t._v(" "),v("h3",{attrs:{id:"weakmap-weakset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weakmap-weakset"}},[t._v("#")]),t._v(" weakMap weakSet")]),t._v(" "),v("ol",[v("li",[t._v("WeakSet\nWeakSet 对象允许你将弱引用对象储存在一个集合中")])]),t._v(" "),v("ul",[v("li",[t._v("成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。")]),t._v(" "),v("li",[t._v("WeakSet 不可迭代，因此不能被用在 for-of 等循环中。")]),t._v(" "),v("li",[t._v("WeakSet 没有 size 属性。")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("WeakMap\nWeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。")])]),t._v(" "),v("ul",[v("li",[t._v("只接受对象作为键名（null 除外），不接受其他类型的值作为键名")]),t._v(" "),v("li",[t._v("键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的")]),t._v(" "),v("li",[t._v("不能遍历，方法有 get、set、has、delete")])]),t._v(" "),v("h3",{attrs:{id:"图片资源优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图片资源优化"}},[t._v("#")]),t._v(" 图片资源优化")]),t._v(" "),v("ol",[v("li",[t._v("使用雪碧图，减少http请求的占用；")]),t._v(" "),v("li",[t._v("图片懒加载；")]),t._v(" "),v("li",[t._v("图片预加载；")]),t._v(" "),v("li",[t._v("使用webp图片格式，优势是同等质量的前提下，webp的体积要比png等要小近百分之二十八左右。")])]),t._v(" "),v("h3",{attrs:{id:"webp-apng"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webp-apng"}},[t._v("#")]),t._v(" webp apng")]),t._v(" "),v("p",[t._v("webp是谷歌于2010年的时候提出的，在保证质量的情况下，体积相比png减少近百分之三十，缺点是兼容性比较差。\napng是Mozilla于2004年推出的，Apng格式是Png的动态形式，是png的扩展，支持半透明，没有锯齿问题，效果上更好。有损压缩后体积比gif小30%，而且没有锯齿。缺点就是兼容性比较差。")]),t._v(" "),v("h3",{attrs:{id:"vue从初始化实例-挂载阶段怎么实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue从初始化实例-挂载阶段怎么实现的"}},[t._v("#")]),t._v(" vue从初始化实例 -> 挂载阶段怎么实现的")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/FrontEndFrame/web-vue-life.html"}},[t._v("vue生命周期详细")])],1)])}),[],!1,null,null,null);a.default=e.exports}}]);